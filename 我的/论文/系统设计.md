# 系统设计

本系统分为服务器与客户端两个部分。客户端为Android平台的app，供用户使用。服务器分为Web服务器和数据库服务器，Web服务器程序由Kotlin编写，能运行在Java虚拟机上。数据库服务器为MongDB，与Web服务器分开能有效保护数据平台和管理访问权限。

系统设计是在系统需求分析的基础上，从开发者的角度针对本系统的需求进行概要设计，以满足系统的需求，为系统实现提供基础。

## 设计目标



## 设计原则



## 系统逻辑架构设计

### 客户端逻辑架构设计

![mvvm](http://img.inaction.fun/static/44037.png)

客户端整体采用MVVM架构，结构图如上图所示。

Activity/Fragment 作为视图层，负责UI显示的相关工作。ViewModel是控制器，负责处理业务逻辑。Repository是数据仓库，负责获取数据、保存数据等数据相关的操作。数据的来源通常有两个地方，一个是网络请求，一个是本地的数据，如数据库或其他文件存储。

MVVM架构的实际工作流程是：当加载一个页面时，首先ViewModel调用Repository的方法，从本地获取缓存数据，通过LiveData将数据变化通知Activity/Fragment，Activity/Fragment 根据数据显示UI。ViewModel继续调用Repository的方法，发送网络请求，从服务器获取数据，拿到数据后同样通过LiveData将数据变化通知Activity/Fragment，Activity/Fragment根据数据变化更新UI。

传统的安卓代码架构是MVC架构，具体是xml文件负责UI显示，Activity/Fragment负责控制器的工作，Model负责数据相关操作，但实际上由于xml的不足，Activity/Fragment既要负责控制器的工作，又要负责UI显示的工作，导致Activity/Fragment负担过重。而在MVVM架构中，Activity/Fragment仅负责UI显示，逻辑控制交给ViewModel，数据操作交给Repository。ViewModel与Activity/Fragment之间的数据传输使用LiveData。在MVVM机构中，Activity/Fragment仅持有ViewModel的引用，ViewModel持有Repository的引用，各个分层之间仅是单向持有，这使得各个组件分工明确，具有非常低的耦合。

除了MVVM外，本应用还采用了单一活动架构。单一活动架构，即一个Android应用仅有一个或少量的Activity，而用Fragment来显示UI，把Activity视为一个大容器，其中Activity内的Fragment代表了屏幕。在Google I/O 2018宣布Jetpack以来**，**还提到了单一活动架构，Google团队打算使该架构更受欢迎。所以，本应用使用了官方的Navigation组件实现了一个符合单一活动架构的应用，其性能与显示效果比传统的架构应用好上不少。

### 服务器逻辑架构设计

服务器使用Kotlin语言进行编写，采用了Ktor框架，整体架构分为数据库、业务逻辑和网络交互三层。下面分别讲述这三层内容的划分。

1. 网络交互层负责接受客户端的http请求并返回相应的数据。本系统的前后端交互的数据格式全部为json格式且接口皆为RESTful接口。为了方便客户端处理不同的情况，所有接口返回的数据皆有 code 与 msg 两个属性，当code不为200时代表请求数据出现错误，msg则为具体的错误原因。
2. 业务逻辑层负责处理具体的业务逻辑，例如当网络层接收到用户的登录请求时，业务逻辑层会执行具体的登录逻辑，在本系统中即检测账号与对应手机验证码的正确性，然后返回登录的结果。
3. 数据库层负责处理数据库相关操作。本系统采用MongoDB数据库，使用Kotlin扩展函数简化了对MongoDB数据库的操作。本系统的数据包括用户数据、标记数据、停车场数据、历史数据和收藏数据。数据层统一处理了系统数据存储、同步，通过业务逻辑层与网络层来数据交互。

## 前后端接口设计

本项目的前后端接口数据均采用json格式，接口共分为5个部分，分别为用户、停车场、标记、历史和收藏。下面列出各个接口的详细设计。

### 用户相关接口



## 数据库设计

本系统使用的数据库是MongoDB，项目一共有5个表，由于MongoDB是NoSQL，数据格式类似与json，所以这里不画ER图设计，而是用json来表示每个表。

### 1.用户表

```json
{
    "_id" : "用户的id，由MongoDB生成的ObjectID",
    "tel" : "用户手机号",
    "name" : "用户名"
}
```

用户表有三个字段，其中_id是用户的唯一id，由MongoDB自动生成，用来唯一标识用户。tel字段是用户的手机号，用户在实际登录或注册时使用自己的手机号而不是id。name字段是用户的名称，注册时由服务器随机生成，也可以在应用内更改。

### 2.停车场表

```json
{
    "_id" : "停车场的id，由MongoDB生成的ObjectID",
    "name" : "停车场名",
    "longitude" : "停车场的经度，double类型",
    "latitude" : "停车场的纬度，double类型",
    "city" : "城市",
    "imgUrl" : "停车场图片的url",
    "totalStallSum" : "总停车位",
    "curStallSum" : "当前剩余停车位",
    "isCollaborated" : "是否是合作停车场",
    "type" : "停车场类型",
    "isCharged" : "是否收费",
    "chargingRules" : "收费规则",
    "rate" : "评分,FLoat类型",
    "commentsNum" : "评论数量",
    "comments" : [
        {
            "userID" : "评论的用户ID",
            "userName" : "评论的用户名",
            "comment" : "评论",
            "timestamp" : "评论的时间戳",
            "rate" : "打分"
        }
    ]
}
```

停车场表的字段较多，下面对几个关键字段进行说明。

* _id

  停车场的唯一id，由MongoDB自动生成，是ObjectID类型。

* longitude，latitude

  停车场的位置的经度和纬度，这两个字段是停车场非常关键的信息，其标示了停车场的位置。应用的许多功能例如距离计算，停车场搜索，导航功能等都需要用到停车场的经度和纬度。
  
* totalStallSum，curStallSum

  停车场的总停车位与当前停车位，这个两个字段是停车场的重要信息，可以帮助用户判断是否要前往停车场。但停车场的当前停车位很多时候是为止的，只有接入系统api的停车场才能即使的知道。

* type

  这个字段代表停车场类型。停车场有许多类型，如地上停车场、地下停车场、路边停车场和未划线停车位。展示停车场的类型信息能帮助用户决定是否要前往该停车场，例如有的用户偏爱未划线停车位，因为其简单快捷。而有的用户会偏爱于地下停车场，因为其可能更适合长时间停放。

* isCharged，chargingRules

  这两个字段分别代表是否收费与收费规则，这也是停车场的重要信息之一。用户在决定是否要去一个停车场停车时往往会关注其是否收费与收费规则。

* rate，comments

  这两个字段分表代表停车场的评分与评论。每一个去过停车场的用户都可以对停车场进行打分和评论，而所有用户的评分会构成停车场的总评分。评分与评论会是用户在选择停车场时的一个重要参考信息。这里comments的字段的数据是一个列表，列表的每一项都是一个评论对象。如果数据库使用的是一般的SQL数据库，就需要一个单独的表来存储评论，得益于MongoDB的特性，停车场的评论数据可以与停车场数据存在一个表中。

### 3.标记表

```json
{
    "_id" : "标记的id，由MongoDB自动生成的ObjectID",
    "userID" : "用户的id",
    "longitude" : "经度",
    "latitude" : "维度",
    "name" : "标记名",
    "radius" : "精度半径（单位米）",
    "time" : "时间戳"
}
```

标记表用来存储用户的标记信息，用户在软件上标记当前位置后，标记的相关数据会上传服务器保存在数据库中。_id字段是标记的唯一id，由MongoDB数据库自动生成；userID字段记录了用户的id，代表这个标记是哪个用户的，当查找一个用户的所有标记时需要根据这个字段；longitude与latitude是标记的经度与纬度，记录了标记的绝对位置；name是标记名，由用户设置，方便用户知道这个标记的意义；radius是精度半径，因为用户在标记位置时使用了手机GPS定位，但定位难免有偏差，这个精度半径及代表定位的偏差，精度半径越小表示精度越高；time是标记的时间，方便用户知道标记是什么时候做的。

### 4.历史记录表

```json
{
    "_id" : "历史记录的唯一id，由MongoDB自动生成的ObjectID",
    "userID" : "用户的id",
    "parkID" : "停车场的id",
    "parkName" : "停车场名",
    "timestamp" : "时间戳"
}
```

历史记录表用来存储用户去过的停车场历史记录，没当用户去过一个停车场后，服务器都会保存相关数据，方便用户查询历史记录。_id字段是一个历史记录的唯一id，由MongoDB数据库自动生成；userID字段记录了用户的id，代表了这个历史记录是属于哪个用户的，当查询一个用户的所有历史记录时需要根据这个字段；parkID是停车场的id，代表用户去的是哪一个停车场，可以根据这个id查询到停车场的详细信息；parkName是停车场名，虽然可以根据parkID查到停车场的信息也包括停车场名，但为了减少查询次数，改善性能，在这里再存储一次停车场名；timestamp是时间戳，代表用户在哪个时间去过该停车场。

### 5.收藏表

```json
{
    "_id" : "收藏记录的唯一id，由MongoDB自动生成的ObjectID",
    "userID" : "用户的id",
    "parkID" : "停车场的id",
    "parkName" : "停车场名",
    "timestamp" : "时间戳"
}
```

当用户收藏某个停车场时，数据库服务器会保存相关信息。收藏表的字段和历史记录表完全一样，含义可参照历史记录表，不再解释。

